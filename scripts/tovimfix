#!/usr/bin/env python3
import argparse
import json
import sys
from typing import Any, NoReturn


def main() -> None:
    args = parse_args()

    try:
        sarif_data = read_sarif(args.input)
    except (json.JSONDecodeError, OSError) as e:
        die(f"Failed to read input: {e}")

    quickfix_entries = parse_sarif(sarif_data, args.separator)

    write_output(args.output, quickfix_entries)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Convert SARIF JSON to Vim quickfix format"
    )
    parser.add_argument(
        "-i",
        "--input",
        help="Input SARIF JSON file (default: stdin)",
    )
    parser.add_argument(
        "-o",
        "--output",
        help="Output file (default: stdout)",
    )
    parser.add_argument(
        "-s",
        "--separator",
        choices=[":", "|"],
        default=":",
        help="Field separator for quickfix entries (default: ':')",
    )
    return parser.parse_args()


def read_sarif(input_path: str | None) -> dict[str, Any]:
    if input_path:
        with open(input_path, "r") as f:
            return json.load(f)
    return json.load(sys.stdin)


def parse_sarif(sarif_data: dict[str, Any], separator: str) -> list[str]:
    entries: list[str] = []

    for run in sarif_data.get("runs", []):
        for result in run.get("results", []):
            try:
                entry = result_to_quickfix(result, separator)
                entries.append(entry)
            except (KeyError, IndexError) as e:
                print(f"Warning: Skipping malformed result: {e}", file=sys.stderr)

    return entries


def result_to_quickfix(result: dict[str, Any], separator: str) -> str:
    location = result["locations"][0]["physicalLocation"]
    uri = location["artifactLocation"]["uri"]

    if "region" in location:
        line = location["region"].get("startLine", 1)
        column = location["region"].get("startColumn", 1)
    else:
        line = 1
        column = 1

    rule_id = result.get("ruleId", "unknown")
    message = result.get("message", {}).get("text", "")

    message_text = f"[{rule_id}] {message}" if message else f"[{rule_id}]"

    return f"{uri}{separator}{line}{separator}{column}{separator}{message_text}"


def write_output(output_path: str | None, entries: list[str]) -> None:
    if output_path:
        with open(output_path, "w") as f:
            for entry in entries:
                print(entry, file=f)
    else:
        for entry in entries:
            print(entry)


def die(message: str) -> NoReturn:
    print(message, file=sys.stderr)
    sys.exit(1)


if __name__ == "__main__":
    main()
